00-Shuffl-alternative-serialization-format-notes.txt

= Shuffl alternative serialization =

= RDF formats =

== Layout ===

=== JSON example ===

{{{
{ "shuffl:id":        "test-shuffl-loadworkspace"
, "shuffl:class":     "shuffl:workspace"
, "shuffl:version":   "0.1"
, "shuffl:base-uri":  "#"
, "shuffl:uses-prefixes":
  [ { "shuffl:prefix":  "shuffl",  "shuffl:uri": "http://purl.org/NET/Shuffl/vocab#" }
  , { "shuffl:prefix":  "rdf",     "shuffl:uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#" }
  , { "shuffl:prefix":  "rdfs",    "shuffl:uri": "http://www.w3.org/2000/01/rdf-schema#" }
  , { "shuffl:prefix":  "owl",     "shuffl:uri": "http://www.w3.org/2002/07/owl#" }
  , { "shuffl:prefix":  "xsd",     "shuffl:uri": "http://www.w3.org/2001/XMLSchema#" }
  ]
, "shuffl:workspace":
  { "shuffl:stockbar":
      [ { "id": "stockpile_1", "class": "stock-yellow",  "label": "Ye", "type": "shuffl-freetext-yellow"  }
      , { "id": "stockpile_2", "class": "stock-blue",    "label": "Bl", "type": "shuffl-freetext-blue"    }
      , { "id": "stockpile_3", "class": "stock-green",   "label": "Gr", "type": "shuffl-freetext-green"   }
      , { "id": "stockpile_4", "class": "stock-orange",  "label": "Or", "type": "shuffl-freetext-orange"  }
      , { "id": "stockpile_5", "class": "stock-pink",    "label": "Pi", "type": "shuffl-freetext-pink"    }
      , { "id": "stockpile_6", "class": "stock-purple",  "label": "Pu", "type": "shuffl-freetext-purple"  }
      ]
  , "shuffl:layout":
      [ { "id": "card_1", "class": "stock_1", "data": "test-shuffl-loadworkspace-card_1.json", "pos": {"left":100, "top":30} }
      , { "id":"card_101"
        , "class":"shuffl-freetext-yellow"
        , "data":"card_101.json"
        , "pos": {"top":0, "left":400}
        , "size": {"width":600,"height":400}
        , "zindex":11
        }


      ]
  }
}
}}}

=== RDF/XML example ===

{{{
<rdf:RDF
    xmlns:shuffl="http://purl.org/NET/Shuffl/vocab#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
    xml:base="#"
>
  <shuffl:Workspace rdf:about="#test-shuffl-loadworkspace">
    <shuffl:base-uri>#</shuffl:base-uri>
    <shuffl:version>0.1</shuffl:version>
    <shuffl:id>test-shuffl-loadworkspace</shuffl:id>
    <shuffl:class>shuffl-freetext-yellow</shuffl:class>
    <shuffl:stockbar rdf:parseType="Collection">
      <rdf:Description>
        <shuffl:id>stockpile_1</shuffl:id>
      </rdf:Description>
    </shuffl:stockbar>
    <shuffl:layout rdf:parseType="Collection">
      <rdf:Description>
        ...
      </rdf:Description>
    </shuffl:layout>
  </shuffl:Workspace/>
</rdf:RDF>
}}}

== Card ==

=== JSON example ===

{{{
{ "shuffl:id":        "id_1"
, "shuffl:class":     "shuffl-freetext-yellow"
, "shuffl:version":   "0.1"
, "shuffl:base-uri":  "#"
, "shuffl:uses-prefixes":
  [ { "shuffl:prefix":  "shuffl", "shuffl:uri": "http://purl.org/NET/Shuffl/vocab#" }
  , { "shuffl:prefix":  "rdf",    "shuffl:uri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#" }
  , { "shuffl:prefix":  "rdfs",   "shuffl:uri": "http://www.w3.org/2000/01/rdf-schema#" }
  , { "shuffl:prefix":  "owl",    "shuffl:uri": "http://www.w3.org/2002/07/owl#" }
  , { "shuffl:prefix":  "xsd",    "shuffl:uri": "http://www.w3.org/2001/XMLSchema#" }
  ]
, "shuffl:data":
  { "shuffl:title":   "Card 1 title"
  , "shuffl:tags":    [ "card_1_tag", "yellowtag" ]
  , "shuffl:text":    "Card 1 free-form text here<br/>line 2<br/>line3<br/>yellow"
  }
}
}}}

=== RDF/XML example ===
{{{
<rdf:RDF
    xmlns:shuffl="http://purl.org/NET/Shuffl/vocab#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
    xml:base="#"
>
  <shuffl:Card rdf:about="#id_1">
    <shuffl:base-uri>#</shuffl:base-uri>
    <shuffl:version>0.1</shuffl:version>
    <shuffl:id>id_1</shuffl:id>
    <shuffl:class>shuffl-freetext-yellow</shuffl:class>
    <shuffl:data>
      <rdf:Description>
        <shuffl:title>Card 1 title</shuffl:title>
        <shuffl:tags>
          <rdf:List>
            <rdf:first>card_1_tag</rdf:first>
            <rdf:rest>
              <rdf:List>
                <rdf:first>yellowtag</rdf:first>
                <rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil" />
              </rdf:List>
            </rdf:rest>
          </rdf:List>
        </shuffl:tags>
        <shuffl:text rdf:parseType="Literal">Card 1 free-form text here<br/>line 2<br/>line3<br/>yellow"</shuffl:text>
      </rdf:Description>
    </shuffl:data>
  </shuffl:Card>
</rdf:RDF>
}}}

= Software interfaces affected =

Current interface functions, and where used.

Assume that a new interface will accept/return a Javascript object as now.

== Module shuffl.loadworkspace ==

session.getData
* shuffl.readCard
* shuffl.loadworkspace

== Module shuffl.saveworkspace ==

shuffl.updateWorkspace
* shuffl.updateCard
  * updateWorkspaceDescription

session.create 
* shuffl.saveCard
* shuffl.saveNewWorkspace
  * saveWorkspaceDescription

session.put
* shuffl.updatecard
* shuffl.updateworkspace
  * updateWorkspaceDescription

= Format selection =

Possible techniques for deciding what format to use when saving/loading Shuffl data.

== Desiderata ==

* Prefer no change to UI
* Able to mix JSON and RDF card data when loading a workspace
* Interchangeable, round-trippable format
* work with local file access and HTTP access

== Options ==

=== Filename extension ===

For:
* meets all desiderata

Against:
* goes against general presumption against the desirability of inferring data 
semantics from URI format.  (But such inference would apply locally to the 
Shuffl applications, not generally across the Web.)
* could fail if uncommon extensions are used

=== Explicit parameter ===

For:
* avoids inferring data semantics from URI form
* can satisfy 2 out of 4 desiderata

Against:
* requires UI change
* doesn't (easily) support format mixing
* requires internal API changes

=== Sniffing ===

For:
* meets all desiderata

Against:
* cannot be used when saving a workspace -> incomplete solution
* possible implementation complexity

== Conclusion for format selection ==

In the first instance, base decision on file extension, as this satisfies all 
immediate requirements and is generally the easiest to implement.

Later, if specific problems are noted, revisit and consider alternatives.

